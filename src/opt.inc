/* -*- Mode: C -*- */
/* Automatically generated by mkswitch. */

static char const *opt_help =
    "General Options\n"
    "    --h\n"
    "    --?\n"
    "    --help\n"
    "        displays this help text\n"
    "    --q\n"
    "    --quiet\n"
    "        suppress all informational messages\n"
    "    --v\n"
    "    --verbose\n"
    "        be more verbose\n"
    "    --o=ARG\n"
    "        sets the output file.  File ending selects default output format:\n"
    "        .stl ending selects --dump-stl format, .scad/.csg selects --dump-csg2,\n"
    "        .ps selects --dump-ps, .js selects --dump-js.\n"
    "    --layer-gap=ARG\n"
    "        gap between layers in STL and SCAD output to ensure 2-manifold [mm]\n"
    "        (default: 0.01)\n"
    "Slicing Options\n"
    "    --min=ARG\n"
    "        min slice z coord [mm] (by default, use bounding box of model,\n"
    "        starting at the middle of the first slice (i.e., at 50% slice\n"
    "        thickness) from the bottom).\n"
    "    --max=ARG\n"
    "        max slice z coord [mm] (default: use bounding box of model)\n"
    "    --step=ARG\n"
    "        thickness of slice [mm] (default: 0.2)\n"
    "    --z=ARG\n"
    "        equivalent to --min COORD --max COORD\n"
#if CP_CSG3_CIRCULAR_CYLINDER
    "    --round-fn=ARG\n"
    "        maximum value of $fn for treating cylinders as polyhedra (default: 200).\n"
    "        At $fn values larger than this, cylinders will be sliced as circular cylinders\n"
    "        and not converted to polyhedra.\n"
#endif
    "    --opt-no-skip-empty\n"
    "    --opt-skip-empty\n"
    "        (do not) skip empty polygons (default: do skip)\n"
    "    --opt-no-drop-collinear\n"
    "    --opt-drop-collinear\n"
    "        (do not) drop inner vertices of two adjacent collinear edges (default: do drop)\n"
    "Advanced Options\n"
    "    --max-simultaneous=ARG\n"
    "        maximum number of polygons to process at once\n"
    "        (minimum: 2, default: " CP_STRINGIFY(CP_CSG2_MAX_LAZY)", using larger values is ignored)\n"
    "    --gran=ARG\n"
    "        rasterization granularity for point coordinates [mm] (default: 0x1p-9)\n"
    "    --eps=ARG\n"
    "        generic comparison epsilon (default: 0x1p-15)\n"
    "    --eps2=ARG\n"
    "        comparison epsilon for squared dimensions (default: 0x1p-30)\n"
    "Intermediate Stage Output/Alternative Output Format Options\n"
    "    --dump-syn\n"
    "        print after stage 1: AST of input file; don't slice\n"
    "    --dump-scad\n"
    "        print after stage 2: SCAD tree, SCAD format; don't slice\n"
    "    --dump-csg3\n"
    "        print after stage 3: 3D CSG model, SCAD format; don't slice\n"
    "    --dump-csg2\n"
    "        print after stage 4: final 2D polygon stack in SCAD format\n"
    "    --dump-ps\n"
    "        print after stage 4: final 2D polygon stack in PostScript format\n"
    "    --dump-stl\n"
    "        print after stage 4: final 2D polygon stack in STL format\n"
    "    --dump-js\n"
    "        print after stage 4: final 2D polygon stack in JavaScript/WebGL format\n"
    "    --no-csg\n"
    "    --csg\n"
    "        for stage 4: do (not) run 2D boolean operation pass\n"
    "    --no-tri\n"
    "    --tri\n"
    "        for stage 4: do (not) run triangulation pass\n"
    "PostScript Output Options\n"
    "    --ps-scale-fit\n"
    "        for --dump-ps: expand to fit normal bounding box to page\n"
    "    --ps-scale-max\n"
    "        for --dump-ps: expand to fit maximum bounding box to page\n"
    "    --ps-no-single-page\n"
    "    --ps-single-page\n"
    "        (do not) print all layers to a single page, bottom to top\n"
    "    --ps-no-tri\n"
    "    --ps-tri\n"
    "        (do not) print triangle boundaries\n"
    "    --ps-no-path\n"
    "    --ps-path\n"
    "        (do not) print paths and points\n"
    "    --ps-no-mark\n"
    "    --ps-mark\n"
    "        (do not) mark the polygon inside with a mark\n"
    "    --ps-no-wire\n"
    "        same as --ps-no-tri --ps-no-path --ps-no-mark\n"
    "    --ps-rot-x=ARG\n"
    "        rotate about x axis by angle\n"
    "    --ps-rot-y=ARG\n"
    "        rotate about y axis by angle\n"
    "    --ps-rot-z=ARG\n"
    "        rotate about z axis by angle\n"
    "    --ps-scale=ARG\n"
    "        scale output on all axes\n"
    "    --ps-persp=ARG\n"
    "        perspective change (1 = 1m toward camera scales by 2)\n"
    "    --ps-color-path=ARG\n"
    "        RGB color of polygon paths\n"
    "    --ps-color-tri=ARG\n"
    "        RGB color of triangle boundaries\n"
    "    --ps-color-fill=ARG\n"
    "        RGB fill color of triangles\n"
    "    --ps-color-vertex=ARG\n"
    "        RGB color of vertices\n"
    "    --ps-color-mark=ARG\n"
    "        RGB color of internal mark\n"
    "    --ps-line-width=ARG\n"
    "        Line width used for polygon paths\n"
    "Debugging Options\n"
#ifdef PSTRACE
    "    --debug-ps=ARG\n"
    "        set name of PostScript debug output file\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-page-skip=ARG\n"
    "        skip this amount of pages before starting to print debug PostScript\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-page-count=ARG\n"
    "        output max this amounts of debug PostScript pages (-1 = no limit)\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-scale-x=ARG\n"
    "        additional horizontal scaling of the debug PostScript output\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-scale-y=ARG\n"
    "        additional vertical scaling of the debug PostScript output\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-scale=ARG\n"
    "        additional scaling of the debug PostScript output\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-xlat-x=ARG\n"
    "        move viewport of the debug PostScript output horizontally\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-xlat-y=ARG\n"
    "        move viewport of the debug PostScript output vertically\n"
#endif
#ifdef PSTRACE
    "    --debug-ps-no-dots\n"
    "    --debug-ps-dots\n"
    "        do (not) draw dots for vertices in debug PostScript output\n"
#endif
    "";

static void get_opt_help(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    help();
}

static void get_opt_csg(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_neg_bool(&opt->no_csg, name, arg);
}

static void get_opt_debug_ps(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *fn __unused)
{
#ifdef PSTRACE

    FILE *f = fopen(fn, "wt");
    if (f == NULL) {
        fprintf(stderr, "Error: Unable to open %s for writing: %s\n",
            fn, strerror(errno));
        my_exit(1);
    }
    cp_debug_ps_file = f;

    CP_CALLOC(cp_debug_ps);
    *cp_debug_ps = *CP_STREAM_FROM_FILE(f);

    cp_ps_doc_begin(cp_debug_ps, &opt->ps,
        CP_SIZE_MAX,
        0, 0, CP_PS_PAPER_X, CP_PS_PAPER_Y);
#endif
}

static void get_opt_debug_ps_dots(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_bool(&cp_debug_ps_dots, name, arg);
#endif
}

static void get_opt_debug_ps_no_dots(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_neg_bool(&cp_debug_ps_dots, name, arg);
#endif
}

static void get_opt_debug_ps_page_count(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_size(&cp_debug_ps_page_count, name, arg);
#endif
}

static void get_opt_debug_ps_page_skip(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_size(&cp_debug_ps_page_skip, name, arg);
#endif
}

static void get_opt_debug_ps_scale(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_scale(&cp_debug_ps_scale_x, name, arg);
    cp_debug_ps_scale_y = cp_debug_ps_scale_x;
#endif
}

static void get_opt_debug_ps_scale_x(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_scale(&cp_debug_ps_scale_x, name, arg);
#endif
}

static void get_opt_debug_ps_scale_y(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_scale(&cp_debug_ps_scale_y, name, arg);
#endif
}

static void get_opt_debug_ps_xlat_x(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_scale(&cp_debug_ps_xlat_x, name, arg);
#endif
}

static void get_opt_debug_ps_xlat_y(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#ifdef PSTRACE
    get_arg_scale(&cp_debug_ps_xlat_y, name, arg);
#endif
}

static void get_opt_dump_csg2(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_csg2, name, arg);
    opt->have_dump = true;
}

static void get_opt_dump_csg3(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_csg3, name, arg);
    opt->have_dump = true;
}

static void get_opt_dump_js(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_js, name, arg);
    opt->have_dump = true;
}

static void get_opt_dump_ps(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_ps, name, arg);
    opt->have_dump = true;
}

static void get_opt_dump_scad(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_scad, name, arg);
    opt->have_dump = true;
}

static void get_opt_dump_stl(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_stl, name, arg);
    opt->have_dump = true;
}

static void get_opt_dump_syn(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->dump_syn, name, arg);
    opt->have_dump = true;
}

static void get_opt_eps(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&cp_eq_epsilon, name, arg);
}

static void get_opt_eps2(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&cp_sqr_epsilon, name, arg);
}

static void get_opt_gran(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&cp_pt_epsilon, name, arg);
}

static void get_opt_layer_gap(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&opt->tree.layer_gap, name, arg);
}

static void get_opt_max(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&opt->z_max, name, arg);
    opt->have_z_max = true;
}

static void get_opt_max_simultaneous(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_size(&opt->tree.max_simultaneous, name, arg);

    if (opt->tree.max_simultaneous < 2) {
        fprintf(stderr, "Error: --max-simultaneous=N: N must be >=2, found %"_Pz"u.\n",
            opt->tree.max_simultaneous);
        my_exit(1);
    }
}

static void get_opt_min(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&opt->z_min, name, arg);
    opt->have_z_min = true;
}

static void get_opt_no_csg(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->no_csg, name, arg);
}

static void get_opt_no_tri(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->no_tri, name, arg);
}

static void get_opt_o(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *fn __unused)
{
    opt->out_file_name = fn;
}

static void get_opt_opt_drop_collinear(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    bool a;
    get_arg_bool(&a, name, arg);
}

static void get_opt_opt_no_drop_collinear(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    bool a;
    get_arg_neg_bool(&a, name, arg);
    opt->tree.optimise = CP_BIT_COPY(opt->tree.optimise, CP_CSG2_OPT_DROP_COLLINEAR, a);
}

static void get_opt_opt_no_skip_empty(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    bool a;
    get_arg_neg_bool(&a, name, arg);
    opt->tree.optimise = CP_BIT_COPY(opt->tree.optimise, CP_CSG2_OPT_SKIP_EMPTY, a);
}

static void get_opt_opt_skip_empty(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    bool a;
    get_arg_bool(&a, name, arg);
}

static void get_opt_ps_color_fill(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_rgb(&opt->ps.color_fill, name, arg);
}

static void get_opt_ps_color_mark(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_rgb(&opt->ps.color_mark, name, arg);
}

static void get_opt_ps_color_path(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_rgb(&opt->ps.color_path, name, arg);
}

static void get_opt_ps_color_tri(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_rgb(&opt->ps.color_tri, name, arg);
}

static void get_opt_ps_color_vertex(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_rgb(&opt->ps.color_vertex, name, arg);
}

static void get_opt_ps_line_width(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&opt->ps.line_width, name, arg);
}

static void get_opt_ps_mark(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_neg_bool(&opt->ps.no_mark, name, arg);
}

static void get_opt_ps_no_mark(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->ps.no_mark, name, arg);
}

static void get_opt_ps_no_path(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->ps.no_path, name, arg);
}

static void get_opt_ps_no_single_page(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_neg_bool(&opt->ps.single_page, name, arg);
}

static void get_opt_ps_no_tri(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->ps.no_tri, name, arg);
}

static void get_opt_ps_no_wire(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    opt->ps.no_tri = true;
    opt->ps.no_path = true;
    opt->ps.no_mark = true;
}

static void get_opt_ps_path(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_neg_bool(&opt->ps.no_path, name, arg);
}

static void get_opt_ps_persp(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_scale(&opt->ps_persp, name, arg);
}

static void get_opt_ps_rot_x(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    cp_angle_t a;
    get_arg_angle(&a, name, arg);
    cp_mat4_t m;
    cp_mat4_rot_x(&m, CP_SINCOS_DEG(a));
    cp_mat4_mul(&opt->ps.xform2, &m, &opt->ps.xform2);
}

static void get_opt_ps_rot_y(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    cp_angle_t a;
    get_arg_angle(&a, name, arg);
    cp_mat4_t m;
    cp_mat4_rot_y(&m, CP_SINCOS_DEG(a));
    cp_mat4_mul(&opt->ps.xform2, &m, &opt->ps.xform2);
}

static void get_opt_ps_rot_z(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    cp_angle_t a;
    get_arg_angle(&a, name, arg);
    cp_mat4_t m;
    cp_mat4_rot_z(&m, CP_SINCOS_DEG(a));
    cp_mat4_mul(&opt->ps.xform2, &m, &opt->ps.xform2);
}

static void get_opt_ps_scale(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    cp_scale_t s;
    get_arg_scale(&s, name, arg);
    cp_mat4_t m;
    cp_mat4_scale1(&m, s);
    cp_mat4_mul(&opt->ps.xform2, &m, &opt->ps.xform2);
}

static void get_opt_ps_scale_fit(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    opt->ps_scale_step = 1;
}

static void get_opt_ps_scale_max(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    opt->ps_scale_step = 2;
}

static void get_opt_ps_single_page(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_bool(&opt->ps.single_page, name, arg);
}

static void get_opt_ps_tri(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_neg_bool(&opt->ps.no_tri, name, arg);
}

static void get_opt_quiet(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    opt->verbose = 0;
}

static void get_opt_round_fn(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
#if CP_CSG3_CIRCULAR_CYLINDER
    get_arg_size(&opt->csg3.max_fn, name, arg);
#endif
}

static void get_opt_step(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&opt->z_step, name, arg);
}

static void get_opt_tri(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_neg_bool(&opt->no_tri, name, arg);
}

static void get_opt_verbose(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    opt->verbose++;
}

static void get_opt_z(
    cp_opt_t *opt __unused,
    char const *name __unused,
    char const *arg __unused)
{
    get_arg_dim(&opt->z_min, name, arg);
    opt->z_max = opt->z_min;
    opt->have_z_min = true;
    opt->have_z_max = true;
}

cp_get_opt_t opt_list[] = {
    {
        "?",
        get_opt_help,
        0,
    },
    {
        "csg",
        get_opt_csg,
        1,
    },
    {
        "debug-ps",
        get_opt_debug_ps,
        2,
    },
    {
        "debug-ps-dots",
        get_opt_debug_ps_dots,
        1,
    },
    {
        "debug-ps-no-dots",
        get_opt_debug_ps_no_dots,
        1,
    },
    {
        "debug-ps-page-count",
        get_opt_debug_ps_page_count,
        2,
    },
    {
        "debug-ps-page-skip",
        get_opt_debug_ps_page_skip,
        2,
    },
    {
        "debug-ps-scale",
        get_opt_debug_ps_scale,
        2,
    },
    {
        "debug-ps-scale-x",
        get_opt_debug_ps_scale_x,
        2,
    },
    {
        "debug-ps-scale-y",
        get_opt_debug_ps_scale_y,
        2,
    },
    {
        "debug-ps-xlat-x",
        get_opt_debug_ps_xlat_x,
        2,
    },
    {
        "debug-ps-xlat-y",
        get_opt_debug_ps_xlat_y,
        2,
    },
    {
        "dump-csg2",
        get_opt_dump_csg2,
        1,
    },
    {
        "dump-csg3",
        get_opt_dump_csg3,
        1,
    },
    {
        "dump-js",
        get_opt_dump_js,
        1,
    },
    {
        "dump-ps",
        get_opt_dump_ps,
        1,
    },
    {
        "dump-scad",
        get_opt_dump_scad,
        1,
    },
    {
        "dump-stl",
        get_opt_dump_stl,
        1,
    },
    {
        "dump-syn",
        get_opt_dump_syn,
        1,
    },
    {
        "eps",
        get_opt_eps,
        2,
    },
    {
        "eps2",
        get_opt_eps2,
        2,
    },
    {
        "gran",
        get_opt_gran,
        2,
    },
    {
        "h",
        get_opt_help,
        0,
    },
    {
        "help",
        get_opt_help,
        0,
    },
    {
        "layer-gap",
        get_opt_layer_gap,
        2,
    },
    {
        "max",
        get_opt_max,
        2,
    },
    {
        "max-simultaneous",
        get_opt_max_simultaneous,
        2,
    },
    {
        "min",
        get_opt_min,
        2,
    },
    {
        "no-csg",
        get_opt_no_csg,
        1,
    },
    {
        "no-tri",
        get_opt_no_tri,
        1,
    },
    {
        "o",
        get_opt_o,
        2,
    },
    {
        "opt-drop-collinear",
        get_opt_opt_drop_collinear,
        1,
    },
    {
        "opt-no-drop-collinear",
        get_opt_opt_no_drop_collinear,
        1,
    },
    {
        "opt-no-skip-empty",
        get_opt_opt_no_skip_empty,
        1,
    },
    {
        "opt-skip-empty",
        get_opt_opt_skip_empty,
        1,
    },
    {
        "ps-color-fill",
        get_opt_ps_color_fill,
        2,
    },
    {
        "ps-color-mark",
        get_opt_ps_color_mark,
        2,
    },
    {
        "ps-color-path",
        get_opt_ps_color_path,
        2,
    },
    {
        "ps-color-tri",
        get_opt_ps_color_tri,
        2,
    },
    {
        "ps-color-vertex",
        get_opt_ps_color_vertex,
        2,
    },
    {
        "ps-line-width",
        get_opt_ps_line_width,
        2,
    },
    {
        "ps-mark",
        get_opt_ps_mark,
        1,
    },
    {
        "ps-no-mark",
        get_opt_ps_no_mark,
        1,
    },
    {
        "ps-no-path",
        get_opt_ps_no_path,
        1,
    },
    {
        "ps-no-single-page",
        get_opt_ps_no_single_page,
        1,
    },
    {
        "ps-no-tri",
        get_opt_ps_no_tri,
        1,
    },
    {
        "ps-no-wire",
        get_opt_ps_no_wire,
        0,
    },
    {
        "ps-path",
        get_opt_ps_path,
        1,
    },
    {
        "ps-persp",
        get_opt_ps_persp,
        2,
    },
    {
        "ps-rot-x",
        get_opt_ps_rot_x,
        2,
    },
    {
        "ps-rot-y",
        get_opt_ps_rot_y,
        2,
    },
    {
        "ps-rot-z",
        get_opt_ps_rot_z,
        2,
    },
    {
        "ps-scale",
        get_opt_ps_scale,
        2,
    },
    {
        "ps-scale-fit",
        get_opt_ps_scale_fit,
        0,
    },
    {
        "ps-scale-max",
        get_opt_ps_scale_max,
        0,
    },
    {
        "ps-single-page",
        get_opt_ps_single_page,
        1,
    },
    {
        "ps-tri",
        get_opt_ps_tri,
        1,
    },
    {
        "q",
        get_opt_quiet,
        0,
    },
    {
        "quiet",
        get_opt_quiet,
        0,
    },
    {
        "round-fn",
        get_opt_round_fn,
        2,
    },
    {
        "step",
        get_opt_step,
        2,
    },
    {
        "tri",
        get_opt_tri,
        1,
    },
    {
        "v",
        get_opt_verbose,
        0,
    },
    {
        "verbose",
        get_opt_verbose,
        0,
    },
    {
        "z",
        get_opt_z,
        2,
    },
};
